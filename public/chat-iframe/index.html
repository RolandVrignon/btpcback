<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chat Iframe</title>
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      background-color: #f5f5f5;
    }
    .chat-container {
      max-width: 600px;
      margin: 20px auto;
      background: white;
      border-radius: 10px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      padding: 20px;
      display: flex;
      flex-direction: column;
      height: calc(100vh - 40px);
    }
    .parameter-display {
      margin-bottom: 20px;
      padding: 15px;
      background: #f9f9f9;
      border-radius: 8px;
      border-left: 4px solid #3498db;
    }
    .parameter-label {
      font-weight: bold;
      margin-bottom: 5px;
      color: #2c3e50;
    }
    .parameter-value {
      word-break: break-all;
      color: #3498db;
    }
    .error-container {
      background-color: #ffebee;
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 20px;
      border-left: 4px solid #f44336;
    }
    .error-title {
      color: #d32f2f;
      font-weight: bold;
      margin-bottom: 8px;
    }
    .error-message {
      color: #c62828;
    }
    .success-indicator {
      color: #2e7d32;
      font-weight: bold;
      margin-top: 10px;
      padding: 10px;
      background-color: #e8f5e9;
      border-radius: 4px;
      text-align: center;
    }
    .chat-messages {
      display: flex;
      flex-direction: column;
      gap: 10px;
      overflow-y: auto;
      flex-grow: 1;
      padding: 10px 0;
    }
    .message {
      max-width: 80%;
      padding: 10px 15px;
      border-radius: 18px;
      margin: 4px 0;
    }
    .message.user {
      align-self: flex-end;
      background-color: #3498db;
      color: white;
      border-bottom-right-radius: 4px;
    }
    .message.ai {
      align-self: flex-start;
      background-color: #f0f0f0;
      color: #333;
      border-bottom-left-radius: 4px;
    }
    .input-area {
      display: flex;
      gap: 10px;
      margin-top: 15px;
      border-top: 1px solid #eee;
      padding-top: 15px;
    }
    .message-input {
      flex-grow: 1;
      padding: 12px;
      border: 1px solid #ddd;
      border-radius: 20px;
      outline: none;
      font-size: 14px;
    }
    .send-button {
      background-color: #3498db;
      color: white;
      border: none;
      border-radius: 20px;
      padding: 0 20px;
      cursor: pointer;
      font-weight: bold;
      transition: background-color 0.2s;
    }
    .send-button:hover {
      background-color: #2980b9;
    }
    .send-button:disabled {
      background-color: #ccc;
      cursor: not-allowed;
    }
    .typing-indicator {
      display: flex;
      padding: 10px 15px;
      background-color: #f0f0f0;
      border-radius: 18px;
      width: fit-content;
      align-self: flex-start;
      margin: 4px 0;
      align-items: center;
    }
    .typing-dot {
      height: 8px;
      width: 8px;
      background-color: #999;
      border-radius: 50%;
      margin-right: 4px;
      animation: typing-bounce 1.4s infinite ease-in-out both;
    }
    .typing-dot:nth-child(1) {
      animation-delay: 0s;
    }
    .typing-dot:nth-child(2) {
      animation-delay: 0.2s;
    }
    .typing-dot:nth-child(3) {
      animation-delay: 0.4s;
      margin-right: 0;
    }
    @keyframes typing-bounce {
      0%, 80%, 100% { transform: scale(0.8); }
      40% { transform: scale(1.2); }
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    // Composant React principal
    const App = () => {
      // Récupérer les paramètres de l'URL
      const [params, setParams] = React.useState({
        projectId: null,
        apiKey: null,
        message: null
      });

      const [authStatus, setAuthStatus] = React.useState({
        verified: false,
        loading: true,
        error: null
      });

      const [messages, setMessages] = React.useState([]);
      const [inputValue, setInputValue] = React.useState('');
      const [isTyping, setIsTyping] = React.useState(false);
      const messagesEndRef = React.useRef(null);

      // Fonction pour faire défiler jusqu'au dernier message
      const scrollToBottom = () => {
        messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
      };

      // Effet pour faire défiler vers le bas lorsque les messages changent
      React.useEffect(() => {
        scrollToBottom();
      }, [messages]);

      React.useEffect(() => {
        // Extraire le projectId de l'URL du chemin
        const pathParts = window.location.pathname.split('/');
        const projectId = pathParts[pathParts.length - 1];

        // Extraire apiKey et message des paramètres de requête
        const urlParams = new URLSearchParams(window.location.search);
        const apiKey = urlParams.get('apiKey');
        const initMessage = urlParams.get('message');

        setParams({
          projectId,
          apiKey,
          message: initMessage
        });

        // Si les paramètres nécessaires sont présents, on considère que l'authentification a réussi
        if (projectId && apiKey) {
          setAuthStatus({
            verified: true,
            loading: false,
            error: null
          });

          // Si un message initial est fourni, l'ajouter à la conversation
          if (initMessage) {
            setMessages([{ content: initMessage, isUser: true }]);
            sendMessage(initMessage, projectId, apiKey);
          }
        } else {
          setAuthStatus({
            verified: false,
            loading: false,
            error: {
              title: "Paramètres manquants",
              message: "L'ID du projet et/ou la clé API sont manquants dans l'URL."
            }
          });
        }
      }, []);

      // Fonction pour envoyer un message au serveur
      const sendMessage = async (message, projectId, apiKey) => {
        try {
          setIsTyping(true);

          // Construire l'URL de l'API avec les paramètres
          const apiUrl = `/chat/${projectId}/message?apiKey=${apiKey}`;
          console.log('Envoi de la requête à:', apiUrl);

          // Faire la requête en mode streaming
          const response = await fetch(apiUrl, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Accept': 'text/event-stream',
            },
            body: JSON.stringify({ message }),
          });

          console.log('Statut de la réponse:', response.status);
          console.log('Headers de la réponse:', Object.fromEntries(response.headers.entries()));

          if (!response.ok) {
            const errorData = await response.text();
            console.error('Erreur de réponse:', {
              status: response.status,
              statusText: response.statusText,
              data: errorData
            });
            throw new Error(`Erreur: ${response.status} - ${errorData}`);
          }

          // Préparer l'objet pour la réponse du bot
          setMessages(prev => [...prev, { content: '', isUser: false }]);

          // Lire le stream
          const reader = response.body.getReader();
          const decoder = new TextDecoder();
          let done = false;
          let text = '';

          while (!done) {
            try {
              const { value, done: doneReading } = await reader.read();
              done = doneReading;

              if (done) {
                console.log('Streaming terminé');
                break;
              }

              // Décoder le chunk et l'ajouter au texte
              const chunk = decoder.decode(value, { stream: true });
              console.log('Chunk reçu:', chunk);

              // Analyser le chunk pour récupérer les données
              const lines = chunk.split('\n');
              let aiResponseText = '';

              for (const line of lines) {
                if (line.startsWith('data:')) {
                  try {
                    const data = JSON.parse(line.slice(5));
                    console.log('Données JSON reçues:', data);
                    if (data && data.text) {
                      aiResponseText += data.text || '';
                    }
                    if (data && data.error) {
                      console.error('Erreur reçue du serveur:', data.error);
                      throw new Error(data.error);
                    }
                  } catch (e) {
                    console.warn('Erreur de parsing JSON:', e);
                    // Continuer si ce n'est pas du JSON valide
                  }
                }
              }

              text += aiResponseText;

              // Mettre à jour le dernier message (celui du bot)
              setMessages(prev => {
                const newMessages = [...prev];
                newMessages[newMessages.length - 1].content = text;
                return newMessages;
              });
            } catch (streamError) {
              console.error('Erreur pendant la lecture du stream:', streamError);
              break;
            }
          }

          setIsTyping(false);
        } catch (error) {
          console.error('Erreur lors de l\'envoi du message:', error);
          setMessages(prev => [...prev, {
            content: "Désolé, une erreur s'est produite lors de la communication avec le serveur.",
            isUser: false
          }]);
          setIsTyping(false);
        }
      };

      // Gestionnaire pour l'envoi de messages
      const handleSendMessage = () => {
        if (!inputValue.trim()) return;

        // Ajouter le message utilisateur
        setMessages(prev => [...prev, { content: inputValue, isUser: true }]);

        // Envoyer au serveur
        sendMessage(inputValue, params.projectId, params.apiKey);

        // Réinitialiser l'entrée
        setInputValue('');
      };

      // Gestionnaire pour le touche "Entrée"
      const handleKeyDown = (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          handleSendMessage();
        }
      };

      if (authStatus.loading) {
        return (
          <div className="chat-container">
            <h1>Chat Iframe</h1>
            <div>Chargement...</div>
          </div>
        );
      }

      return (
        <div className="chat-container">
          <h1>Chat IA</h1>

          {!authStatus.verified && authStatus.error && (
            <div className="error-container">
              <div className="error-title">{authStatus.error.title}</div>
              <div className="error-message">{authStatus.error.message}</div>
            </div>
          )}

          {authStatus.verified && (
            <>
              <div className="chat-messages">
                {messages.map((msg, index) => (
                  <div key={index} className={`message ${msg.isUser ? 'user' : 'ai'}`}>
                    {msg.content}
                  </div>
                ))}
                {isTyping && (
                  <div className="typing-indicator">
                    <div className="typing-dot"></div>
                    <div className="typing-dot"></div>
                    <div className="typing-dot"></div>
                  </div>
                )}
                <div ref={messagesEndRef} />
              </div>

              <div className="input-area">
                <textarea
                  className="message-input"
                  value={inputValue}
                  onChange={(e) => setInputValue(e.target.value)}
                  onKeyDown={handleKeyDown}
                  placeholder="Écrivez votre message ici..."
                  disabled={isTyping}
                />
                <button
                  className="send-button"
                  onClick={handleSendMessage}
                  disabled={!inputValue.trim() || isTyping}
                >
                  Envoyer
                </button>
              </div>
            </>
          )}
        </div>
      );
    };

    // Rendre le composant React dans l'élément root
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>